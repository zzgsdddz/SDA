# Plot histogram with different kernel choices
hist(sample_data, probability = TRUE, main = "Density Estimators - Kernels", col = "lightgray", border = "black")
for (i in seq_along(kernels)) {
lines(density(sample_data, kernel = kernels[i]), col = colors_kernels[i], lwd = 2)
}
legend("topright", legend = kernels, col = colors_kernels, lwd = 2, title = "Kernels")
# Plot histogram with different bandwidth choices
hist(sample_data, probability = TRUE, main = "Density Estimators - Bandwidths", col = "lightgray", border = "black")
for (i in seq_along(bandwidths)) {
lines(density(sample_data, bw = bandwidths[i]), col = colors_bandwidths[i], lwd = 2)
}
legend("topright", legend = paste("bw =", round(bandwidths, 2)), col = colors_bandwidths, lwd = 2, title = "Bandwidths")
# Set seed for reproducibility
set.seed(123)
# Generate random sample from t-distribution with 3 degrees of freedom
n <- 20
sample_data <- rt(n, df = 3)
# Define different kernel types
kernels <- c("gaussian", "epanechnikov", "rectangular", "triangular")
colors_kernels <- c("red", "blue", "green", "purple")
# Define different bandwidth choices
bandwidths <- c(density(sample_data)$bw, 0.3, 1.5)
colors_bandwidths <- c("red", "blue", "green")
# Create side-by-side plots
par(mfrow = c(1, 2))  # Split the plotting area into two side-by-side plots
# Plot histogram with different kernel choices
hist(sample_data, probability = TRUE, main = "Density Estimators - Kernels", col = "lightgray", border = "black")
for (i in seq_along(kernels)) {
lines(density(sample_data, kernel = kernels[i]), col = colors_kernels[i], lwd = 2)
}
legend("topright", legend = kernels, col = colors_kernels, lwd = 2, title = "Kernels")
# Plot histogram with different bandwidth choices
hist(sample_data, probability = TRUE, main = "Density Estimators - Bandwidths", col = "lightgray", border = "black")
for (i in seq_along(bandwidths)) {
lines(density(sample_data, bw = bandwidths[i]), col = colors_bandwidths[i], lwd = 2)
}
legend("topright", legend = paste("bw =", round(bandwidths, 2)), col = colors_bandwidths, lwd = 2, title = "Bandwidths")
h_opt <- function(x) {
sigma_hat <- min(sd(x), IQR(x) / 1.34)  # Compute standard deviation and interquartile range
h_optimal <- 1.06 * sigma_hat * length(x)^(-1/5)  # Optimal bandwidth formula
return(h_optimal)
}
# Compute optimal bandwidth for the sample
h_opt_value <- h_opt(sample_data)
# Compare with R's default bandwidth
default_bw <- density(sample_data)$bw
# Print results
cat("Optimal Bandwidth (h_opt):", h_opt_value, "\n")
cat("Default R Bandwidth:", default_bw, "\n")
# Set seed for reproducibility
set.seed(123)
# Generate random sample from t-distribution with 3 degrees of freedom
n <- 20
sample_data <- rt(n, df = 3)
# Define different kernel types
kernels <- c("gaussian", "epanechnikov", "rectangular", "triangular")
colors_kernels <- c("red", "blue", "green", "purple")
# Define different bandwidth choices
bandwidths <- c(density(sample_data)$bw, 0.3, 1.5)
colors_bandwidths <- c("red", "blue", "green")
# Create side-by-side plots
par(mfrow = c(1, 2))  # Split the plotting area into two side-by-side plots
# Add legend outside the plot
legend("topright", inset = c(-0.3, 0), legend = kernels, col = colors_kernels, lwd = 2, title = "Kernels", xpd = TRUE)
# Set seed for reproducibility
# Set seed for reproducibility
set.seed(123)
# Generate random sample from t-distribution with 3 degrees of freedom
n <- 20
sample_data <- rt(n, df = 3)
# Define different kernel types and colors
kernels <- c("gaussian", "epanechnikov", "rectangular", "triangular")
colors_kernels <- c("red", "blue", "green", "purple")
# Define different bandwidth choices and colors
bandwidths <- c(density(sample_data)$bw, 0.3, 1.5)
colors_bandwidths <- c("red", "blue", "green")
# Adjust plot margins to make space for legends
par(mfrow = c(1, 2), mar = c(5, 4, 4, 8))  # Extra right margin for the legend
# Plot histogram with different kernel choices
hist(sample_data, probability = TRUE, main = "Density Estimators - Kernels", col = "lightgray", border = "black")
for (i in seq_along(kernels)) {
lines(density(sample_data, kernel = kernels[i]), col = colors_kernels[i], lwd = 2)
}
# Add legend outside the plot
legend("topright", inset = c(-0.3, 0), legend = kernels, col = colors_kernels, lwd = 2, title = "Kernels", xpd = TRUE)
# Plot histogram with different bandwidth choices
hist(sample_data, probability = TRUE, main = "Density Estimators - Bandwidths", col = "lightgray", border = "black")
for (i in seq_along(bandwidths)) {
lines(density(sample_data, bw = bandwidths[i]), col = colors_bandwidths[i], lwd = 2)
}
# Add legend outside the plot
legend("topright", inset = c(-0.3, 0), legend = paste("bw =", round(bandwidths, 2)), col = colors_bandwidths, lwd = 2,
title = "Bandwidths", xpd = TRUE)
h_opt <- function(x) {
sigma_hat <- min(sd(x), IQR(x) / 1.34)  # Compute standard deviation and interquartile range
h_optimal <- 1.06 * sigma_hat * length(x)^(-1/5)  # Optimal bandwidth formula
return(h_optimal)
}
# Compute optimal bandwidth for the sample
h_opt_value <- h_opt(sample_data)
# Compare with R's default bandwidth
default_bw <- density(sample_data)$bw
# Print results
cat("Optimal Bandwidth (h_opt):", h_opt_value, "\n")
cat("Default R Bandwidth:", default_bw, "\n")
# Set seed for reproducibility
# Set seed for reproducibility
set.seed(123)
# Generate random sample from t-distribution with 3 degrees of freedom
n <- 20
sample_data <- rt(n, df = 3)
# Define different kernel types and colors
kernels <- c("gaussian", "epanechnikov", "rectangular", "triangular")
colors_kernels <- c("red", "blue", "green", "purple")
# Define different bandwidth choices and colors
bandwidths <- c(density(sample_data)$bw, 0.3, 1.5)
colors_bandwidths <- c("red", "blue", "green")
# Adjust plot margins to make space for legends
par(mfrow = c(1, 2), mar = c(5, 4, 4, 8))  # Extra right margin for the legend
# Plot histogram with different kernel choices
hist(sample_data, probability = TRUE, main = "Density Estimators - Kernels", col = "lightgray", border = "black")
for (i in seq_along(kernels)) {
lines(density(sample_data, kernel = kernels[i]), col = colors_kernels[i], lwd = 2)
}
# Add legend outside the plot
legend("topright", inset = c(-0.3, 0), legend = kernels, col = colors_kernels, lwd = 2, title = "Kernels", xpd = TRUE)
# Plot histogram with different bandwidth choices
hist(sample_data, probability = TRUE, main = "Density Estimators - Bandwidths", col = "lightgray", border = "black")
for (i in seq_along(bandwidths)) {
lines(density(sample_data, bw = bandwidths[i]), col = colors_bandwidths[i], lwd = 2)
}
# Add legend outside the plot
legend("topright", inset = c(-0.3, 0), legend = paste("bw =", round(bandwidths, 2)), col = colors_bandwidths, lwd = 2,
title = "Bandwidths", xpd = TRUE)
h_opt <- function(x) {
sigma_hat <- min(sd(x), IQR(x) / 1.34)  # Compute standard deviation and interquartile range
h_optimal <- 1.06 * sigma_hat * length(x)^(-1/5)  # Optimal bandwidth formula
return(h_optimal)
}
# Compute optimal bandwidth for the sample
h_opt_value <- h_opt(sample_data)
# Compare with R's default bandwidth
default_bw <- density(sample_data)$bw
# Print results
cat("Optimal Bandwidth (h_opt):", h_opt_value, "\n")
cat("Default R Bandwidth:", default_bw, "\n")
# Set seed for reproducibility
set.seed(123)
# Generate random sample from t-distribution with 3 degrees of freedom
n <- 20
sample_data <- rt(n, df = 3)
# Define different kernel types and colors
kernels <- c("gaussian", "epanechnikov", "rectangular", "triangular")
colors_kernels <- c("red", "blue", "green", "purple")
# Define different bandwidth choices and colors
bandwidths <- c(density(sample_data)$bw, 0.3, 1.5)
colors_bandwidths <- c("red", "blue", "green")
# Adjust layout to have extra space for legends
layout(matrix(c(1, 2, 3), ncol = 3), widths = c(3, 3, 1)) # Third column for legends
# Plot histogram with different kernel choices
par(mar = c(5, 4, 4, 2)) # Reset margins for better spacing
hist(sample_data, probability = TRUE, main = "Density Estimators - Kernels", col = "lightgray", border = "black")
for (i in seq_along(kernels)) {
lines(density(sample_data, kernel = kernels[i]), col = colors_kernels[i], lwd = 2)
}
# Leave a blank plot for legend
plot.new()
legend("center", legend = kernels, col = colors_kernels, lwd = 2, title = "Kernels", bty = "n")
# Plot histogram with different bandwidth choices
par(mar = c(5, 4, 4, 2)) # Reset margins
hist(sample_data, probability = TRUE, main = "Density Estimators - Bandwidths", col = "lightgray", border = "black")
for (i in seq_along(bandwidths)) {
lines(density(sample_data, bw = bandwidths[i]), col = colors_bandwidths[i], lwd = 2)
}
# Leave a blank plot for legend
plot.new()
legend("center", legend = paste("bw =", round(bandwidths, 2)), col = colors_bandwidths, lwd = 2, title = "Bandwidths", bty = "n")
h_opt <- function(x) {
sigma_hat <- min(sd(x), IQR(x) / 1.34)  # Compute standard deviation and interquartile range
h_optimal <- 1.06 * sigma_hat * length(x)^(-1/5)  # Optimal bandwidth formula
return(h_optimal)
}
# Compute optimal bandwidth for the sample
h_opt_value <- h_opt(sample_data)
# Compare with R's default bandwidth
default_bw <- density(sample_data)$bw
# Print results
cat("Optimal Bandwidth (h_opt):", h_opt_value, "\n")
cat("Default R Bandwidth:", default_bw, "\n")
# Set seed for reproducibility
set.seed(123)
# Generate random sample from t-distribution with 3 degrees of freedom
n <- 20
sample_data <- rt(n, df = 3)
# Define different kernel types and colors
kernels <- c("gaussian", "epanechnikov", "rectangular", "triangular")
colors_kernels <- c("red", "blue", "green", "purple")
# Define different bandwidth choices and colors
bandwidths <- c(density(sample_data)$bw, 0.3, 1.5)
colors_bandwidths <- c("red", "blue", "green")
# Adjust layout to have extra space for legends
layout(matrix(c(1, 2, 3), ncol = 3), widths = c(3, 3, 1)) # Third column for legends
# Plot histogram with different kernel choices
par(mar = c(5, 4, 4, 2)) # Reset margins for better spacing
hist(sample_data, probability = TRUE, main = "Density Estimators - Kernels", col = "lightgray", border = "black")
for (i in seq_along(kernels)) {
lines(density(sample_data, kernel = kernels[i]), col = colors_kernels[i], lwd = 2)
}
# Leave a blank plot for legend
plot.new()
legend("center", legend = kernels, col = colors_kernels, lwd = 2, title = "Kernels", bty = "n")
# Plot histogram with different bandwidth choices
par(mar = c(5, 4, 4, 2)) # Reset margins
hist(sample_data, probability = TRUE, main = "Density Estimators - Bandwidths", col = "lightgray", border = "black")
for (i in seq_along(bandwidths)) {
lines(density(sample_data, bw = bandwidths[i]), col = colors_bandwidths[i], lwd = 2)
}
# Leave a blank plot for legend
plot.new()
legend("center", legend = paste("bw =", round(bandwidths, 2)), col = colors_bandwidths, lwd = 2, title = "Bandwidths", bty = "n")
h_opt <- function(x) {
sigma_hat <- min(sd(x), IQR(x) / 1.34)  # Compute standard deviation and interquartile range
h_optimal <- 1.06 * sigma_hat * length(x)^(-1/5)  # Optimal bandwidth formula
return(h_optimal)
}
# Compute optimal bandwidth for the sample
h_opt_value <- h_opt(sample_data)
# Compare with R's default bandwidth
default_bw <- density(sample_data)$bw
# Print results
cat("Optimal Bandwidth (h_opt):", h_opt_value, "\n")
cat("Default R Bandwidth:", default_bw, "\n")
# Set seed for reproducibility
set.seed(123)
# Generate random sample from t-distribution with 3 degrees of freedom
n <- 20
sample_data <- rt(n, df = 3)
# Define different kernel types and colors
kernels <- c("gaussian", "epanechnikov", "rectangular", "triangular")
colors_kernels <- c("red", "blue", "green", "purple")
# Define different bandwidth choices and colors
bandwidths <- c(density(sample_data)$bw, 0.3, 1.5)
colors_bandwidths <- c("red", "blue", "green")
# Adjust plot margins to make space for legends
par(mfrow = c(1, 2), mar = c(5, 4, 4, 8))  # Extra right margin for the legend
# Plot histogram with different kernel choices
hist(sample_data, probability = TRUE, main = "Density Estimators - Kernels", col = "lightgray", border = "black")
for (i in seq_along(kernels)) {
lines(density(sample_data, kernel = kernels[i]), col = colors_kernels[i], lwd = 2)
}
# Add legend outside the plot
legend("topright", inset = c(-0.3, 0), legend = kernels, col = colors_kernels, lwd = 2, title = "Kernels", xpd = TRUE)
# Plot histogram with different bandwidth choices
hist(sample_data, probability = TRUE, main = "Density Estimators - Bandwidths", col = "lightgray", border = "black")
for (i in seq_along(bandwidths)) {
lines(density(sample_data, bw = bandwidths[i]), col = colors_bandwidths[i], lwd = 2)
}
# Add legend outside the plot
legend("topright", inset = c(-0.3, 0), legend = paste("bw =", round(bandwidths, 2)), col = colors_bandwidths, lwd = 2,
title = "Bandwidths", xpd = TRUE)
h_opt <- function(x) {
sigma_hat <- min(sd(x), IQR(x) / 1.34)  # Compute standard deviation and interquartile range
h_optimal <- 1.06 * sigma_hat * length(x)^(-1/5)  # Optimal bandwidth formula
return(h_optimal)
}
# Compute optimal bandwidth for the sample
h_opt_value <- h_opt(sample_data)
# Compare with R's default bandwidth
default_bw <- density(sample_data)$bw
# Print results
cat("Optimal Bandwidth (h_opt):", h_opt_value, "\n")
cat("Default R Bandwidth:", default_bw, "\n")
# Set seed for reproducibility
set.seed(123)
# Generate random sample from t-distribution with 3 degrees of freedom
n <- 20
sample_data <- rt(n, df = 3)
# Define different kernel types and colors
kernels <- c("gaussian", "epanechnikov", "rectangular", "triangular")
colors_kernels <- c("red", "blue", "green", "purple")
# Define different bandwidth choices and colors
bandwidths <- c(density(sample_data)$bw, 0.3, 1.5)
colors_bandwidths <- c("red", "blue", "green")
# Adjust plot margins to make space for legends
par(mfrow = c(1, 2), mar = c(5, 4, 4, 8))  # Extra right margin for the legend
# Plot histogram with different kernel choices
hist(sample_data, probability = TRUE, main = "Density Estimators - Kernels", col = "lightgray", border = "black")
for (i in seq_along(kernels)) {
lines(density(sample_data, kernel = kernels[i]), col = colors_kernels[i], lwd = 2)
}
# Add legend outside the plot
legend("topright", inset = c(-0.3, 0), legend = kernels, col = colors_kernels, lwd = 2, title = "Kernels", xpd = TRUE)
# Plot histogram with different bandwidth choices
hist(sample_data, probability = TRUE, main = "Density Estimators - Bandwidths", col = "lightgray", border = "black")
for (i in seq_along(bandwidths)) {
lines(density(sample_data, bw = bandwidths[i]), col = colors_bandwidths[i], lwd = 2)
}
# Add legend outside the plot
legend("topright", inset = c(-0.3, 0), legend = paste("bw =", round(bandwidths, 2)), col = colors_bandwidths, lwd = 2,
title = "Bandwidths", xpd = TRUE)
h_opt <- function(x) {
sigma_hat <- min(sd(x), IQR(x) / 1.34)  # Compute standard deviation and interquartile range
h_optimal <- 1.06 * sigma_hat * length(x)^(-1/5)  # Optimal bandwidth formula
return(h_optimal)
}
# Compute optimal bandwidth for the sample
h_opt_value <- h_opt(sample_data)
# Compare with R's default bandwidth
default_bw <- density(sample_data)$bw
# Print results
cat("Optimal Bandwidth (h_opt):", h_opt_value, "\n")
cat("Default R Bandwidth:", default_bw, "\n")
# Set seed for reproducibility
set.seed(123)
# Generate random sample from t-distribution with 3 degrees of freedom
n <- 20
sample_data <- rt(n, df = 3)
# Define different kernel types and colors
kernels <- c("gaussian", "epanechnikov", "rectangular", "triangular")
colors_kernels <- c("red", "blue", "green", "purple")
# Define different bandwidth choices and colors
bandwidths <- c(density(sample_data)$bw, 0.3, 1.5)
colors_bandwidths <- c("red", "blue", "green")
# Adjust plot margins to make space for legends
par(mfrow = c(1, 2), mar = c(5, 4, 4, 8))  # Extra right margin for the legend
# Plot histogram with different kernel choices
hist(sample_data, probability = TRUE, main = "Density Estimators - Kernels", col = "lightgray", border = "black")
for (i in seq_along(kernels)) {
lines(density(sample_data, kernel = kernels[i]), col = colors_kernels[i], lwd = 2)
}
# Add legend outside the plot
legend("topright", inset = c(-0.3, 0), legend = kernels, col = colors_kernels, lwd = 2, title = "Kernels", xpd = TRUE)
# Plot histogram with different bandwidth choices
hist(sample_data, probability = TRUE, main = "Density Estimators - Bandwidths", col = "lightgray", border = "black")
for (i in seq_along(bandwidths)) {
lines(density(sample_data, bw = bandwidths[i]), col = colors_bandwidths[i], lwd = 2)
}
# Add legend outside the plot
legend("topright", inset = c(-0.5, 0), legend = paste("bw =", round(bandwidths, 2)), col = colors_bandwidths, lwd = 2,
title = "Bandwidths", xpd = TRUE)
h_opt <- function(x) {
sigma_hat <- min(sd(x), IQR(x) / 1.34)  # Compute standard deviation and interquartile range
h_optimal <- 1.06 * sigma_hat * length(x)^(-1/5)  # Optimal bandwidth formula
return(h_optimal)
}
# Compute optimal bandwidth for the sample
h_opt_value <- h_opt(sample_data)
# Compare with R's default bandwidth
default_bw <- density(sample_data)$bw
# Print results
cat("Optimal Bandwidth (h_opt):", h_opt_value, "\n")
cat("Default R Bandwidth:", default_bw, "\n")
# Set seed for reproducibility
set.seed(123)
# Generate random sample from t-distribution with 3 degrees of freedom
n <- 20
sample_data <- rt(n, df = 3)
# Define different kernel types and colors
kernels <- c("gaussian", "epanechnikov", "rectangular", "triangular")
colors_kernels <- c("red", "blue", "green", "purple")
# Define different bandwidth choices and colors
bandwidths <- c(density(sample_data)$bw, 0.3, 1.5)
colors_bandwidths <- c("red", "blue", "green")
# Adjust plot margins to make space for legends
par(mfrow = c(1, 2), mar = c(5, 4, 4, 8))  # Extra right margin for the legend
# Plot histogram with different kernel choices
hist(sample_data, probability = TRUE, main = "Density Estimators - Kernels", col = "lightgray", border = "black")
for (i in seq_along(kernels)) {
lines(density(sample_data, kernel = kernels[i]), col = colors_kernels[i], lwd = 2)
}
# Add legend outside the plot
legend("topright", inset = c(-1, 0), legend = kernels, col = colors_kernels, lwd = 2, title = "Kernels", xpd = TRUE)
# Plot histogram with different bandwidth choices
hist(sample_data, probability = TRUE, main = "Density Estimators - Bandwidths", col = "lightgray", border = "black")
for (i in seq_along(bandwidths)) {
lines(density(sample_data, bw = bandwidths[i]), col = colors_bandwidths[i], lwd = 2)
}
# Add legend outside the plot
legend("topright", inset = c(-1, 0), legend = paste("bw =", round(bandwidths, 2)), col = colors_bandwidths, lwd = 2,
title = "Bandwidths", xpd = TRUE)
h_opt <- function(x) {
sigma_hat <- min(sd(x), IQR(x) / 1.34)  # Compute standard deviation and interquartile range
h_optimal <- 1.06 * sigma_hat * length(x)^(-1/5)  # Optimal bandwidth formula
return(h_optimal)
}
# Compute optimal bandwidth for the sample
h_opt_value <- h_opt(sample_data)
# Compare with R's default bandwidth
default_bw <- density(sample_data)$bw
# Print results
cat("Optimal Bandwidth (h_opt):", h_opt_value, "\n")
cat("Default R Bandwidth:", default_bw, "\n")
# Set seed for reproducibility
set.seed(123)
# Generate random sample from t-distribution with 3 degrees of freedom
n <- 20
sample_data <- rt(n, df = 3)
# Define different kernel types and colors
kernels <- c("gaussian", "epanechnikov", "rectangular", "triangular")
colors_kernels <- c("red", "blue", "green", "purple")
# Define different bandwidth choices and colors
bandwidths <- c(density(sample_data)$bw, 0.3, 1.5)
colors_bandwidths <- c("red", "blue", "green")
# Adjust plot margins to make space for legends
par(mfrow = c(1, 2), mar = c(5, 4, 4, 8))  # Extra right margin for the legend
# Plot histogram with different kernel choices
hist(sample_data, probability = TRUE, main = "Density Estimators - Kernels", col = "lightgray", border = "black")
for (i in seq_along(kernels)) {
lines(density(sample_data, kernel = kernels[i]), col = colors_kernels[i], lwd = 2)
}
# Add legend outside the plot
legend("topright", inset = c(-1.2, 0), legend = kernels, col = colors_kernels, lwd = 2, title = "Kernels", xpd = TRUE)
# Plot histogram with different bandwidth choices
hist(sample_data, probability = TRUE, main = "Density Estimators - Bandwidths", col = "lightgray", border = "black")
for (i in seq_along(bandwidths)) {
lines(density(sample_data, bw = bandwidths[i]), col = colors_bandwidths[i], lwd = 2)
}
# Add legend outside the plot
legend("topright", inset = c(-1, 0), legend = paste("bw =", round(bandwidths, 2)), col = colors_bandwidths, lwd = 2,
title = "Bandwidths", xpd = TRUE)
h_opt <- function(x) {
sigma_hat <- min(sd(x), IQR(x) / 1.34)  # Compute standard deviation and interquartile range
h_optimal <- 1.06 * sigma_hat * length(x)^(-1/5)  # Optimal bandwidth formula
return(h_optimal)
}
# Compute optimal bandwidth for the sample
h_opt_value <- h_opt(sample_data)
# Compare with R's default bandwidth
default_bw <- density(sample_data)$bw
# Print results
cat("Optimal Bandwidth (h_opt):", h_opt_value, "\n")
cat("Default R Bandwidth:", default_bw, "\n")
# Set seed for reproducibility
set.seed(123)
# Generate random sample from t-distribution with 3 degrees of freedom
n <- 20
sample_data <- rt(n, df = 3)
# Define different kernel types and colors
kernels <- c("gaussian", "epanechnikov", "rectangular", "triangular")
colors_kernels <- c("red", "blue", "green", "purple")
# Define different bandwidth choices and colors
bandwidths <- c(density(sample_data)$bw, 0.3, 1.5)
colors_bandwidths <- c("red", "blue", "green")
# Adjust plot margins to make space for legends
par(mfrow = c(1, 2), mar = c(5, 4, 4, 8))  # Extra right margin for the legend
# Plot histogram with different kernel choices
hist(sample_data, probability = TRUE, main = "Density Estimators - Kernels", col = "lightgray", border = "black")
for (i in seq_along(kernels)) {
lines(density(sample_data, kernel = kernels[i]), col = colors_kernels[i], lwd = 2)
}
# Add legend outside the plot
legend("topright", inset = c(-1.2, 0), legend = kernels, col = colors_kernels, lwd = 2, title = "Kernels", xpd = TRUE)
# Plot histogram with different bandwidth choices
hist(sample_data, probability = TRUE, main = "Density Estimators - Bandwidths", col = "lightgray", border = "black")
for (i in seq_along(bandwidths)) {
lines(density(sample_data, bw = bandwidths[i]), col = colors_bandwidths[i], lwd = 2)
}
# Add legend outside the plot
legend("topright", inset = c(-1, 0), legend = paste("bw =", round(bandwidths, 2)), col = colors_bandwidths, lwd = 2, cex = 0.8,
title = "Bandwidths", xpd = TRUE)
h_opt <- function(x) {
sigma_hat <- min(sd(x), IQR(x) / 1.34)  # Compute standard deviation and interquartile range
h_optimal <- 1.06 * sigma_hat * length(x)^(-1/5)  # Optimal bandwidth formula
return(h_optimal)
}
# Compute optimal bandwidth for the sample
h_opt_value <- h_opt(sample_data)
# Compare with R's default bandwidth
default_bw <- density(sample_data)$bw
# Print results
cat("Optimal Bandwidth (h_opt):", h_opt_value, "\n")
cat("Default R Bandwidth:", default_bw, "\n")
# Set seed for reproducibility
set.seed(123)
# Generate random sample from t-distribution with 3 degrees of freedom
n <- 20
sample_data <- rt(n, df = 3)
# Define different kernel types and colors
kernels <- c("gaussian", "epanechnikov", "rectangular", "triangular")
colors_kernels <- c("red", "blue", "green", "purple")
# Define different bandwidth choices and colors
bandwidths <- c(density(sample_data)$bw, 0.3, 1.5)
colors_bandwidths <- c("red", "blue", "green")
# Adjust plot margins to make space for legends
par(mfrow = c(1, 2), mar = c(5, 4, 4, 8))  # Extra right margin for the legend
# Plot histogram with different kernel choices
hist(sample_data, probability = TRUE, main = "Density Estimators - Kernels", col = "lightgray", border = "black")
for (i in seq_along(kernels)) {
lines(density(sample_data, kernel = kernels[i]), col = colors_kernels[i], lwd = 2)
}
# Add legend outside the plot
legend("topright", inset = c(-1.2, 0), legend = kernels, col = colors_kernels, lwd = 2, cex = 0.8, title = "Kernels", xpd = TRUE)
# Plot histogram with different bandwidth choices
hist(sample_data, probability = TRUE, main = "Density Estimators - Bandwidths", col = "lightgray", border = "black")
for (i in seq_along(bandwidths)) {
lines(density(sample_data, bw = bandwidths[i]), col = colors_bandwidths[i], lwd = 2)
}
# Add legend outside the plot
legend("topright", inset = c(-1, 0), legend = paste("bw =", round(bandwidths, 2)), col = colors_bandwidths, lwd = 2, cex = 0.8,
title = "Bandwidths", xpd = TRUE)
h_opt <- function(x) {
sigma_hat <- min(sd(x), IQR(x) / 1.34)  # Compute standard deviation and interquartile range
h_optimal <- 1.06 * sigma_hat * length(x)^(-1/5)  # Optimal bandwidth formula
return(h_optimal)
}
# Compute optimal bandwidth for the sample
h_opt_value <- h_opt(sample_data)
# Compare with R's default bandwidth
default_bw <- density(sample_data)$bw
# Print results
cat("Optimal Bandwidth (h_opt):", h_opt_value, "\n")
cat("Default R Bandwidth:", default_bw, "\n")
